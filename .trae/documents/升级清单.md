**第一阶段：高价值兼容性增强（优先级最高）**

- 支持 **灰度 JPEG（单通道）**  
  - 目标：`SOF` 里只有一个组件时，正确解码成 RGB（复制到 R/G/B）。  
  - 影响：很多缩略图、扫描件、黑白图可直接支持。

- 支持 **标准 CMYK JPEG 解码到 sRGB**（不管 ICC，先做简单公式）  
  - 目标：遇到 4 分量 JPEG，按常见约定 `C,M,Y,K → RGB`（简单反转/乘法）输出。  
  - 影响：Photoshop / 印刷导出的部分图片不再“花色”或者直接失败。

- 支持 **YCCK → sRGB 的简单路径**  
  - 目标：对带 APP2/ICC 但常见 YCCK 的文件，按固定近似矩阵做 YCCK→CMYK→RGB。  
  - 实现可以参考 ImageSharp 的 `JpegColorConverter.FromYccK*` 思路，简化参数。

- 增强 **Progressive JPEG 的稳健性**  
  - 目标：用一组合适的测试图（可以借 ImageSharp 测试资源），确保较常见的扫描顺序/Refinement 全部能出结果。  
  - 重点：检查你当前的 “多次扫描累积 DC/AC、successive approximation 重构” 是否覆盖典型情况。

---

**第二阶段：色彩管理与元数据（提升“专业度”的部分）**

- 基础 **ICC Profile 解析 + sRGB 对齐**（解码侧）  
  - 目标：从 APP2 里获取 ICC Profile，当 Profile 标明已是 sRGB 时，信任它；当是常见 AdobeRGB/Display P3 等时，可以先只标记，后续再做真正转换。  
  - 最小版本：只暴露元数据到 `JpegMetadata`/类似对象，不立刻做复杂色彩空间变换。

- EXIF 元数据扩展（除 Orientation 之外）  
  - 目标：解析 EXIF 中的一些关键字段（拍摄时间、相机型号、GPS 等），挂到一个简单 Metadata 对象上。  
  - 先只“读出来并挂在对象上”，不一定要在转换流程里使用。

- 写入侧保留/复制基本元数据  
  - 目标：在重新编码 JPEG 时，选择性保留关键 APP1（EXIF）/APP0 信息，避免“导出图像后元数据全丢”。  
  - 可以提供选项：`KeepMetadata = true/false`。

---

**第三阶段：性能与工程质量提升**

- IDCT 与颜色转换 **向量化/优化**  
  - 目标：基于现有整数 IDCT，把内部循环适度向量化（`System.Numerics.Vector<T>`），在不改算法的前提下提升吞吐。  
  - 参考：ImageSharp 的 `FastFloatingPointDCT`、`Block8x8F` 的布局方式。

- Huffman 解码路径拆分与缓存优化  
  - 目标：将 `JpegDecoder` 中 Huffman 相关部分抽象成独立类（类似 `HuffmanScanDecoder`），并对快速路径做 LUT（例如 8-bit 前缀表）。  
  - 效果：提高大图、多 MCU 的解码速度，同时让代码更可维护。

- 尺寸、采样、流错误的 **更友好错误处理**  
  - 目标：对于截断文件、错误 restart、异常 marker，上报更清晰的异常类型/信息，而不是统一 `InvalidDataException`。  
  - 可引入几个细分异常：`JpegHeaderException`、`JpegScanException` 等。

- 编码侧多线程/分块并行（可选）  
  - 目标：对于大图，在编码时按 MCU 行并行执行 DCT+量化，利用多核 CPU。  
  - 需要注意：写位流时必须串行，考虑“生产块数据 → 串行写出”模式。

---

**第四阶段：标准补完（“完美主义”向，可选）**

- **Arithmetic Coding**（算术编码）支持  
  - 目标：能识别并解码算术编码 JPEG；必要时提供开关允许禁用。  
  - 现实：极少见，更多是为了“规范完整性”。

- **Lossless JPEG（SOF3 等）**  
  - 目标：支持基于预测 + 差分的 JPEG 无损模式；可输出为 RGB 或灰度。  
  - 实际用途：医疗、科研图像等小众领域。

- **12-bit JPEG 支持**  
  - 目标：支持 12-bit 采样，内部可以转为 16-bit/浮点再下采样到 8-bit 输出。  
  - 成本较高，需要改动 IDCT、量化、颜色转换的数据路径宽度。

- 更完整的 **Hierarchical / Multi-Frame JPEG**  
  - 目标：能解析并合成分层 JPEG，或至少识别并给出明确“不支持”的错误。  
  - 现实：基本是“为了把规范读全”级别。

---

**推荐推进顺序（简版）**

1. 第一阶段：灰度 + CMYK/YCCK → sRGB + 强化 Progressive（兼容性收益最大）。  
2. 第二阶段：ICC/元数据（对需要图像信息的上层业务很有价值）。  
3. 第三阶段：性能和工程质量（等接口比较稳定后再做）。  
4. 第四阶段：完全是兴趣/标准完备度驱动，根据时间精力考虑。

如果你愿意，我们可以从“第一阶段的某一项”直接开干，例如：  
先做「灰度 + CMYK JPEG 支持」，我可以基于你现在的 `JpegDecoder` 帮你设计一下具体改动点和接口风格。

---

**附录 A：JpegDecoder 重构要点（整理自 Refactor and Improve JpegDecoder）**

- 架构与拆分
  - 现有 `JpegDecoder.cs` 体积较大，适合拆分出下列内部类型到独立文件：`JpegMarkers`、`JpegBitReader`、`JpegIDCT`、`FrameHeader`、`ScanHeader`、`Component`。
  - 将这些类型统一归类到 `Formats\Jpeg` 命名空间下，便于后续维护和单独测试。
- 数据结构统一
  - 已有 `JpegQuantTable`、`JpegHuffmanTable` 类型，应避免在 `JpegDecoder` 内重复定义等价结构。
  - 引入 `HuffmanDecodingTable` 这样的“解码用视图”，负责生成 `MaxCode/MinCode/ValPtr` 与快速查表数组。
- 性能相关的改进点
  - 避免将整个 JPEG 流读入 `byte[]` 再解码，优先以 `Stream` 为输入，配合位读取器逐步消费。
  - 在 IDCT 与 RGB 输出阶段减少小数组的重复分配，复用块缓冲与行缓冲。
- 错误处理与 API 形态
  - 用更具体的异常替代 `Exception` 与 `Console.WriteLine`：如尺寸错误用 `InvalidDataException`，不支持特性用 `NotSupportedException`。
  - 解码结果以 `Image<Rgb24>` 返回，而不是裸 `byte[]`，与整体 `Core.Image` 抽象对齐。

以上内容已在当前代码演进中部分落地，保留下来作为后续重构与回归检查的参考。

---

**附录 B：渐进式 JPEG 支持现状与后续方向（整理自 progress_support_task_list）**

- 已完成的能力
  - 解析 SOF2（`0xFFC2`），在帧头上标记 Progressive。
  - 在 SOS 阶段解析并保存 `Ss/Se/Ah/Al`，用于区分 DC 初始扫描、AC 初始扫描与后续细化扫描。
  - 为每个组件、每个块维护 64 维系数缓冲，在多次扫描中累积 DC/AC 系数。
  - 实现：
    - DC 初始扫描（`Ss=0, Se=0`），含 successive approximation 的高位/细化位处理；
    - AC 初始扫描（`Ss>=1`），支持 `EOB`、`ZRL` 与符号位存储；
  - 在 restart marker 处正确复位 DC 预测值与位状态，遍历完所有扫描后再统一做 IDCT + 上采样 + 颜色转换。
  - 保持 Baseline 与 Progressive 路径的兼容性，根据帧类型选择不同的解码流程。
- 尚未覆盖/后续可迭代的部分
  - AC 细化扫描的完整支持（含 `EOBRUN`、细化位插入新非零系数等）。
  - 更全面的测试集：引入典型 Progressive JPEG（多种扫描顺序和 refinement 组合），保证都能稳定解码并避免严重色偏。
- 与升级阶段的关系
  - 上述已完成功能对应“第一阶段：高价值兼容性增强”中的 Progressive 部分。
  - 后续可以在完善 AC 细化与测试覆盖的基础上，配合第三阶段的 Huffman/IDCT 性能优化，进一步提高 Progressive 场景下的大图吞吐。
